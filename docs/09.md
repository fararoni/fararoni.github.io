
# Ejercicio 9. Resolvers

## 9.1 Fuente de datos  API Rest

### 1. Clonar el repositorio
En una ventana CMD, ir al directorio c:\sc, clonar el repositorio de inicio de la aplicaci√≥n:
```bash
cd c:\sc
git clone https://github.com/fararoni/curso.graphql.odyssey-lift-off-part2.git
```
### 2. Ejecutar la aplicaci√≥n de lado del servidor
```bash
cd c:\sc\curso.graphql.odyssey-lift-off-part2\server
code .
```
Abra una terminal de Visual Studio Code y ejecute los siguientes comandos para instalar las dependencias y ejecutar la aplicaci√≥n:
```bash
npm install
npm start
```
√∫nicamente ver√° un mensaje final ‚Äúnodemon‚Äù

### 3. Catstronauts REST API
Ingresar a la siguente direcci√≥n del servicio API REST

```javascript
https://odyssey-lift-off-rest-api.herokuapp.com/docs/
```
Observar la documentaci√≥n de los seis endpoints disponibles
```javascript
	GET   /tracks
	GET   /track/:id
	PATCH /track/:id
	GET   /track/:id/modules
	GET   /author/:id
	GET   /module/:id
```

### 4. /tracks
. Revisa la documentaci√≥n del endpoint GET   /tracks, pru√©bale haciendo click en el boton ***'Try it out!'***  y luego en **_Execute_** .

Obtenermos Recibimos una respuesta JSON:
```javascript
[
  {
    "id": "c_0",
    "thumbnail": "https://res.cloudinary.com/dety84pbu/image/upload/v1598465568/nebula_cat_djkt9r.jpg",
    "topic": "Cat-stronomy",
    "authorId": "cat-1",
    "title": "Cat-stronomy, an introduction",
    "description": "Curious to learn what Cat-stronomy is all about? Explore the planetary and celestial alignments and how they have affected our space missions.",
    "numberOfViews": 10,
    "numberOfLikes": 0,
    "createdAt": "2018-09-10T07:13:53.020Z",
    "length": 2377,
    "modulesCount": 10,
    "modules": [
      "l_0",
      "l_1",
      "l_2",
      "l_3",
      "l_4",
      "l_5",
      "l_6",
      "l_7",
      "l_8",
      "l_9"
    ]
  },
  { . . . }
```
La respuesta incluye una lista de Track's. Veamos con m√°s detalle en qu√© coincide con nuestro esquema GraphQL, remiti√©ndonos al tipo Track  :
```graphql
	type Track {
	  id: ID!
	  title: String!
	  author: Author!
	  thumbnail: String
	  length: Int
	  modulesCount: Int
	}
```
vs

```javascript
[
  {
    "id": "c_0",
    "thumbnail": " . . ",
    "topic": "Cat-stronomy",
    "authorId": "cat-1",
    "title": ". . .",
    "description": ". . ..",
    "numberOfViews": 10,
    "numberOfLikes": 0,
    "createdAt": "2018-09-10T07:13:53.020Z",
    "length": 2377,
    "modulesCount": 10,
    "modules": [ "l_0", "l_1","l_2",...,"l_9"
    ]
  },
  { . . . }
```

El arreglo incluye propiedades que necesitamos incluir en la el componente Tracks Card:

-   `id`
-   `thumbnail`
-   `title`
-   `modulesCount`
-   `length`

Y tambien hay campos que no vamos a usar por el momento
-   `topic`
-   `description`
-   `numberOfViews`
-   `createdAt`
-   `modules`


### 5. /tracks `/author/:id`
El arreglo no incluye la informaci√≥n de `author` aunque si viene el campos `authorId`. Y tambien tenemos el endpoint `/author/:id` que dado el par√°metro `id`retorna los detalles de dicho author. Obtenga el nombre del author 'cat-5'

Veamos  nuestro esquema GraphQL, remiti√©ndonos al tipo Author:

```graphql
	type  Author  {
	  id:  ID!
	  name:  String!
	  photo:  String
	}
```
vs 
```javascript
	{
	  "id": "cat-5",
	  "name": "Thomas O'Malley",
	  "photo": "https://images.unsplash.com/photo... &ixid=eyJhcHBfaWQiOjExNzA0OH0"
	}
```

> Necesitaremos llamar a este endpoint ***`/author/:id`*** por cada
> track en la lista que recibimos en el endpoint  ***`/track`*** anterior.
> Luego necesitaremos unir los resultados para entregarlos en la forma de
> los datos que nuestro resolver y nuestra query esperan.

## 9.2 Apollo RESTDataSource

Nuestro servidor GraphQL necesita acceder a esa API REST para obtener los datos. Se pueden hacer llamados directos usando `fetch`,  oen su lugar usar una pr√°ctica clase auxiliar llamada `DataSource`. Esta clase se ocupa de algunos desaf√≠os y limitaciones que conlleva el enfoque directo.

 - Usando `node-fetch`, se recuperan todos los `track's` desde nuestro endpoint `/track`.
 - A√∫n falta recuperar la informaci√≥n del `author`
 - Para cada track en la lista devuelta por `/track`, necesitamos hacer un llamado al endpoint`/author/:id`

1.  Usando `node-fetch`, ¬øCuantas llamadas se debe realizar para obtener la lista de `tracks` y el nombre de su `author`, para el caso que la lista de tracks devuelva 100 registros?

_Env√≠e su respuesta al chat_

2.  Usando `node-fetch`, Si el `author`de todos los tracks fuera el mismo, ¬øCuantas llamdas al endpoint `/author/:id` se tendr√≠an que realizar, tomando el caso que la lista de tracks devuelva 100 registros.

_Env√≠e su respuesta al chat_

> El problema N+1 en GraphQL tambien existe,  es un problema de
> rendimiento que puede ocurrir cuando se solicitan datos anidados en
> una consulta GraphQL. El problema se produce porque GraphQL ejecuta
> una funci√≥n de resoluci√≥n separada para cada campo, lo que significa
> que puede haber una resoluci√≥n separada para cada elemento de datos
> anidado.
```javascript
{
  tracks {
    # 1
    title
    author {
      # N calls for N tracks
      name
    }
  }
}
```
Al implementar  `RESTDataSource` en el servidor en lugar de `fetch`, se reducen los desaf√≠os que acabamos de ver.

## 9.3 Implementar  RESTDataSource en el server

1. En la terminal de Visual Studio donde tiene corriendo el server, interrumpa su ejecuci√≥n y ejecute el siguiente comando (Directorio de trabajo c:\sc\curso.graphql.odyssey-lift-off-part2\server)

```bash
<ctrl>+<c>
npm install @apollo/datasource-rest
npm start
```
2. A continuaci√≥n, creemos una carpeta llamada `datasources`en la carpeta `server/src`, donde residir√°n todas nuestras fuentes de datos . Crearemos un archivo llamado`track-api.js` .

3. Abrir el archivo e importar el  paquete @apollo/datasource-rest en la primer l√≠nea.

```javascript
const  { RESTDataSource }  =  require("@apollo/datasource-rest");
```
4. Declararar una clase llamada `TrackAPI` que extends `RESTDataSource`.

```javascript
	class  TrackAPI  extends  RESTDataSource {
		// ...
	}
	module.exports  =  TrackAPI; // Debe exportar
```
5. Asignar la url del API REST a la propiedad `baseURL`. Esta propiedad se utiliza como prefijo de todas las llamadas.
```javascript
	class TrackAPI extends RESTDataSource {
	  baseURL = "https://odyssey-lift-off-rest-api.herokuapp.com/";
	}
```

6. Agregar el m√©todo  `getTracksForHome` a la clase  `TrackAPI` para indicarle que realice un GET request al endpoint `tracks`. `this.get`  es un m√©todo _helper_ proporcionado por RESTDataSource.
```javascript
		getTracksForHome() {
			console.log('getTracksForHome')
			return this.get('tracks'); 
		}
```
7.  Agregar el m√©todo  `getAuthor` a la clase  `TrackAPI`. Este m√©todo necesita un par√°metro  `authorId` e invocar el endpoint `/author/:id`.

```javascript
		getAuthor(authorId) { 
			console.log(`--- getAuthor ${authorId}` )
			return this.get(`author/${authorId}`); 
		}
```

## 9.4 Implementar el resolver

> Un resolver es una funci√≥n. Tiene el mismo nombre que el campo para el
> que obtiene los datos. Puede recuperar datos de cualquier fuente de
> datos y luego transformar esos datos en la forma que   requiere el
> client.

1. En la carpeta  en la carpeta `server/src`, crea un archivo llamado`resolvers.js` .
2. Declarar la constante `resolvers`y asignar un objeto vac√≠o, y exportarla.

```javascript
const  resolvers  = {};

module.exports  =  resolvers;	
```
Los nombres de las claves de nuestro objeto resolvers corresponder√°n a los tipos y campos de nuestro esquema.

 - Para crear un resolver para el campo tracksForHome, primero agregaremos una clave Query a nuestro objeto resolvers.
 - El valor de esa clave ser√° otro objeto que contenga la clave tracksForHome.
 - La clave tracksForHome es donde definiremos nuestra funci√≥n de resolver para el campo correspondiente.

3. Agregar lo siguiente en el objetos resolvers
```javascript
	Query: {
	  // returns an array of Tracks that will be used to populate
	  // the homepage grid of our web client
	  tracksForHome: () => {},
	},
```
4. Agregar los par√°metros opcionales del resolver. Complemente la siguiente l√≠nea:

```javascript
	tracksForHome:  (parent, args, contextValue, info)  =>  {},
```
> El orden/posici√≥n de los par√°metros es importante para el resolutor.
> Para acceder a las fuentes de datos se requiere contextValue. Se desestructura para acceder a su objeto hijo dataSources
> Si no se van a usar los dos primeros, por convenci√≥n se usa un gui√≥n bajo para el primero y dos guiones bajos para el segundo

5. Desestructurar contextValue para extraer su objeto `dataSources` 

```javascript
	    tracksForHome: (_, __, { dataSources }) => {},
```
6. Ya que tenemos acceso a `dataSources`, acceder a `trackAPI` la instancia de `TrackAPI`e invocarmos el m√©todo `getTracksForHome`.
```javascript
	tracksForHome: (_, __, { dataSources }) => {
	     return dataSources.trackAPI.getTracksForHome(); 
    },
```
7. Obtener el autor asociado a cada `track`.  El m√©todo `getAuthor` del `dataSources` nos entrega el author asociado a cada `track`. Por lo que podriamos recorrer los datos de los `tracks` devueltos, tomar la propiedad authorId de cada pista y llamar a getAuthor con ella. 
	¬øQue problema de rendimiento generar√≠a esta soluci√≥n?
	_Env√≠e su respuesta al chat_	
	
8. Agregar otro resolutor espec√≠ficamente para el autor de un `track`. Agregar otra clave al objeto `resolvers` que llamaremos  `Track` indicando que es para el tipo `Track`de nuestro esquema.  Dentro de esa clave Track habr√° otro objeto con un campo author, donde definiremos nuestro resolutor.
```javascript
	Track:  {
		author:  (parent, args, contextValue, info)  =>  {},
	}
```

> El m√©todo getAuthor de TrackAPI necesita un authorId. Obtendremos este
> valor del argumento parent pasado al resolutor. El argumento parent
> contiene los datos devueltos por nuestro resolutor tracksForHome, y
> debido a que tracksForHome devuelve una lista, Apollo Server itera a
> trav√©s de esa lista y llama al resolutor de autor una vez por cada
> pista.

9. Desestructurar `authorId` del par√°metro `parent`y a continuaci√≥n hacer el llamado al m√©todo `getAuthor`del datasource:
 
```javascript
 Track: {
    author: ({ authorId }, _, { dataSources }) => {
      return dataSources.trackAPI.getAuthor(authorId);
    },
  },
```

> Mejor pr√°ctica para Apollo Server.  Como buena pr√°ctica, al trabajar en tus resolutores y
> fuentes de datos, trata de mantener las funciones de resoluci√≥n lo m√°s
> delgadas posible. Al hacerlo, vuelves tu API m√°s resistente a cambios
> futuros. Puedes refactorizar tu c√≥digo de obtenci√≥n de datos de manera
> segura o cambiar la fuente por completo de una API REST a una base de
> datos, sin romper tu API. Esto tambi√©n mantiene tus resolutores
> legibles y m√°s f√°ciles de entender

## 9.4 Conectar el `schema`, `resolver`y `datasource`

Abrir el archivo `server/src/index.js` y vas a sustiruir la fuente de datos mock con los resolvers.

1. Hacer los siguientes cambios (Lo que est√° marcado con un - al principio son l√≠neas que deben sustituirse o suprimirse).

```javascript
const { ApolloServer } = require('@apollo/server');
const { startStandaloneServer } = require('@apollo/server/standalone');
- const { addMocksToSchema } = require('@graphql-tools/mock');
- const { makeExecutableSchema } = require('@graphql-tools/schema');
const typeDefs = require('./schema');
- const mocks = {
-  Query: () => ({
-    tracksForHome: () => [...new Array(6)],
-  }),
-  Track: () => ({
-    id: () => 'track_01',
-    title: () => 'Astro Kitty, Space Explorer',
-    author: () => {
-      return {
-        name: 'Grumpy Cat',
-        photo: 'https://res.cloudinary.com/dety84pbu/image/upload/v1606816219/kitty-veyron-sm_mctf3c.jpg',
-      };
-    },
-    thumbnail: () => 'https://res.cloudinary.com/dety84pbu/image/upload/v1598465568/nebula_cat_djkt9r.jpg',
-    length: () => 1210,
-    modulesCount: () => 6,
-  }),
- };
async function startApolloServer() {
  const server = new ApolloServer({
-    schema: addMocksToSchema({
-      schema: makeExecutableSchema({ typeDefs }),
-      mocks,
-    }),
  });
  const { url } = await startStandaloneServer(server);
  console.log(`
    üöÄ  Server is running
    üì≠  Query at ${url}
  `);
}
startApolloServer();
```

2. Importar el resolver. Agregar la siguiente l√≠nea al principio del archivo index.js
```javascript
	const  resolvers  =  require("./resolvers");
```

3. Agregar typeDefs y  resolvers a las opciones de  ApolloServer.
```javascript
	const server = new ApolloServer({
	  typeDefs,
	  resolvers,
	});
```

4. Importar el datasource, despues de la primer linea donde se import√≥ el `resolver` agregar
```javascript
	const  TrackAPI  =  require("./datasources/track-api");
```

5. Conectar el servidor con el datasource definido en `TrackAPI` agregar un segundo par√°metro al m√©todo `startStandaloneServer`. A trav√©s de este par√°metro se va a signar la propiedad `contextValue` que compartir√°n todos los resolvers. Aqu√≠ tambien se asignar√° la propiedad dataSources que se desestructur√≥ en los resolvers y que devuelve un objeto TrackAPI por medio de la clave trackAPI.

Modificar la l√≠nea para que quede de la siguiente forma
```javascript
	const { url } = await startStandaloneServer(server, {
  context: async () => {
    return {
      dataSources: {
        trackAPI: new TrackAPI(),
      },
    };
  },
});
```
6. Para mejorar el rendimiento por medio del cach√©, desestructurar la propiedad del server y pasarla a la clase TrackAPI. Actualizar:

```javascript
 const { url } = await startStandaloneServer(server, {
  context: async () => {
    const { cache } = server;
    return {
      dataSources: {
        trackAPI: new TrackAPI({ cache }),
      },
    };
  },
});
```
## 9.5 Consultar los datos 

 - Abrir el Explorer en Apollo Sandbox [http://localhost:4000](http://localhost:4000/)  si no est√° ejecutando el server, levantarlo con
```bash
	npm start
```
1. Ejecutar la consulta guardada
```graphql
	query GetTracks {
	  tracksForHome {
	    id
	    title
	    thumbnail
	    length
	    modulesCount
	    author {
	      id
	      name
	      photo
	    }
	  }
	}
```
2. Actualiza el archivo resolver.js, para agregar verificar el comportamiento uso del cache. Solicita la consulta tres  veces, Muestra el tiempo de la primer consulta y el tiempo de la tercera consulta.
Si no observas ningun cambio, interrumpe el servidor y vuelve a levantarlo.

```javascript
	tracksForHome: (_, __, { dataSources }) => {
            const date1 = new Date();
            const tracks =   dataSources.trackAPI.getTracksForHome(); 
            const date2 = new Date();
            const diffInMs = date2 - date1; 
            console.log('Diff : ' + date2 - date1);
            return tracks;
       },
```
_Env√≠e su respuesta al chat_

4. Archivos creados o modificados:
 - schema.js
 - track-api.js
 - resolver.js
 - index.js
 - 
## 9.6 Frontend 

### 1. Abrir el proyecto frontend react

Abrir una Ventana CMD, ir al directorio C:\sc\curso.graphql.odyssey-lift-off-part1\client y abrir Visual Studio Code:.
```bash
	cmd
	cd c:\sc\curso.graphql.odyssey-lift-off-part2\client
	code .
```
Desde visual studio, abrir una terminal CMD y ejecutar
```bash
	npm start
```

### 2. Abrir el navegador en http://127.0.0.1:3000
